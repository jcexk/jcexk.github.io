---
layout: post
title: "趣说虚拟/物理地址"
date:   2021-04-20
tags: [程序员的自我修养]
comments: true
author: jcexk
---
### 讲个小故事
>一天匿名网友江某心去A图书馆借书，这个图书馆历史比较久，设施也不完善，江某见状，大摇大摆就闯了进去(A图书馆很大，里面放了很多排的书架，每个书架又可以放16* 1024* 1024本书，为了方便管理这么多的书都是按照编号顺序摆放)。不法市民江某不仅仅借了书，甚至在地理刊物上把日本也改成了中国领土不可分割的一部分。事后图书馆安全升级，规定借书只能先找管理员。
>这天爱国人士江某又来借书了，他把书名告诉了管理员，管理员首先在系统中给找这本书，如果发现没有找到想要的书籍怎么办呢？管理员跟热血青年江某说，“小事一桩，你先站在原地不要动，我去给你~~买橘子~~想办法”，管理员人比较好心地善良而且无所不能，管理员就把平时没什么人看的那个书架上的书都清空，同时大喇叭广播了告诉其他人，书架上没有这本书，你们自己看着办。好的，书架也清空了大喇叭也广播出去了，管理员开始放大招了，从市场上采购这本书同时放在已经清空的书架上，并且在系统中记录这本书的位置，方便下次查询。

## 1. 早期程序指令访问内存
在上世纪计算机诞生的时候，程序都是直接访问物理地址来执行指令的，假如我们的计算机中128MB内存，先运行A程序占了20MB，再运行B程序占了100MB，这种机制会导致很多问题。
* **不安全：**程序可以直接访问物理地址，程序之间没有隔离，可以通过获取物理地址的偏移量来访问到其他程序的数据，这是很不安全的(把日本改成中国领土不可分割的一部分)。
* **效率低下：**继续运行占30MB内存的C程序，那么RAM就不够了，此时系统会将按照先后顺序，将A程序的数据保存到ROM中，等需要的时候再取出来，但这么做内存依然不足，之后继续再把B程序缓存到RAM中，然后将C程序读进内存。在硬盘上大量的读写操作，导致效率也是十分低下。
* **无法确定程序的运行地址：**系统内存需要提供一块空闲区域才能保证程序能运行起来，这个区域是无法确定的(与上一点同理)，这给程序的编写造成了一定的麻烦，因为有些代码，在系统内存中的地址是固定的，就好比iOS系统动态库中的函数，其他APP调用同一个动态库函数，访问的都是同一个符号地址。

为了解决以上问题，人们在程序与内存之间增加了一个中间层(**MMU:memory management unit**)，相当于前言中管理员角色，MMU是一种负责处理中央处理器（CPU）的内存访问请求的计算机硬件。它的功能包括虚拟地址到物理地址的转换（即虚拟内存管理）。MMU把程序进程给出的虚拟地址空间作为虚拟空间，同时也给程序分配相应大小的物理空间，然后通过MMU，映射到对应的物理地址上，这样就能做到了程序之间的地址隔绝。
![图片来源：维基百科https://en.wikipedia.org/wiki/Memory_management_unit](https://raw.githubusercontent.com/jcexk/jcexk.github.io/master/images/pagefault/640px-MMU_principle_updated-1.png)
* **虚拟地址**   
地址范围的大小由CPU的位数决定，例如一个32位的CPU，它的地址范围是0~0xFFFFFFFF （4G)，而对于一个64位的CPU，它的地址范围为0~0xFFFFFFFFFFFFFFFF （16E)。这个范围就是我们的程序能够产生的地址范围，我们把这个地址范围称为虚拟地址空间，该空间中的某一个地址我们称之为虚拟地址；虚拟地址是虚拟的、并不真实存在的，每个程序都有自己的独立虚拟空间。
* **物理地址**   
与虚拟地址空间和虚拟地址相对应的则是物理地址空间和物理地址，大多数时候我们的系统所具备的物理地址空间只是虚拟地址空间的一个子集。这里举一个最简单的例子直观地说明这两者，对于一台内存为256M的32bit x86主机来说，它的虚拟地址空间范围是0~0xFFFFFFFF（4G），而物理地址空间范围是0x00000000 ~ 0x0FFFFFFF（256M）。物理空间是真实存在的，可以把它联想为ROM，而物理地址就是物理空间上的索引。

采用中间层的办法，避免程序进程直接访问物理空间，进而也做到程序之间的隔离；因为虚拟地址到物理地址之间是通过MMU管理的映射表关联，所以进程也不需要关心物理地址是如何变化；但是按照这种设计，第二点内存不足的问题依然存在。
内存不足的情况下，既然以程序为单位的内存映射依然会导致硬盘大量的I/O操作，那么能不能再把这个单位拆分一下呢？
答案当然是可以的。
## 2. 分页：
计算机会对虚拟内存地址空间（32位为4G）分页产生页（page），对物理内存地址空间（假设256M）分页产生页帧（page frame），这个页和页帧的大小是一样大的，所以呢，虚拟内存页的个数势必要大于物理内存页帧的个数。
![-w488](https://raw.githubusercontent.com/jcexk/jcexk.github.io/master/images/pagefault/16185076041222.jpg)

## 3. Page Fault
在计算机上有一个页表（page table），就是映射虚拟内存页到物理内存页的，更确切的说是页号到页帧号的映射，而且是一对一的映射。但是问题来了，虚拟内存页的个数 > 物理内存页帧的个数，岂不是有些虚拟内存页的地址永远没有对应的物理内存地址空间？肯定不会的。
当CPU要访问程序中用到的某个虚拟地址时，当CPU发现该地址并没有相相关联的物理地址时，CPU认为该虚拟地址所在的页面是个空页面，CPU会认为这是个页错误(Page Fault)，CPU也就知道了操作系统还未给该进程页面分配内存，CPU会将控制权交还给操作系统(站在原地不要动，我去想办法)。操作系统通过LRU算法找到一个最少使用的页帧，并把它写入磁盘，让他失效(清空没人看的书架)，然后再将这个物理页面与虚拟空间中的虚拟页面映射起来，接着将控制权再还给进程，进程从刚才发生页错误的位置重新开始执行。由于此时已为进程的那个页面分配了内存，所以就不会发生页错误了。随着程序的执行，页错误会不断地产生，操作系统也会为进程分配相应的物理页面来满足进程执行的需求。这就是发生`page fault`时的处理步骤。 

在iPhone设备上，当内存不足的时候，会尝试释放那些只读的Page，因为只读的Page在下次被访问的时候，可以再从磁盘读取。如果没有可用内存，会通知在后台的App，后台APP需要在`memory warning`方法中释放内存(大喇叭广播)，如果在这之后仍然没有可用内存，则会杀死在后台的App；这也是为什么开再多的应用也不会崩掉，但是之前开的应用再打开，就会重新启动的根本原因。

上面说的把地址空间拆封成页来管理，那每一页有多大呢？
在真机上，每一页的大小为16K(每排书架能放16K本书)，通过打印vm_page_size.h中的`vm_page_size`可知
![模拟器](https://raw.githubusercontent.com/jcexk/jcexk.github.io/master/images/pagefault/16188517575735.jpg)
![真机](https://raw.githubusercontent.com/jcexk/jcexk.github.io/master/images/pagefault/16188517241921.jpg)
## 4. 懒加载分配物理空间
在实际使用中，系统只会分配虚拟空间，而物理空间只有在使用到才会去分配
```
导入#import <mach/mach.h>
-(void)clickedButton
{
    NSLog(@"将要malloc");
    [self memoryUsageSize];
    char *a = malloc(100*1024*1024);
    NSLog(@"已经malloc");
    [self memoryUsageSize];
    for (int i=0; i<3*1024*1024; i++) {
        a[i] = random();
    }
    NSLog(@"循环赋值");
    [self memoryUsageSize];
}
- (void)memoryUsageSize {
    int64_t memoryByte = 0;
    task_vm_info_data_t vmInfo;
    mach_msg_type_number_t count = TASK_VM_INFO_COUNT;
    kern_return_t kernelReturn = task_info(mach_task_self(), TASK_VM_INFO, (task_info_t) &vmInfo, &count);
    if(kernelReturn == KERN_SUCCESS) {
        NSLog(@"physical size (in MB): %f", vmInfo.phys_footprint/1024.0/1024.0);
        NSLog(@"virtual size  (in MB): %f", vmInfo.virtual_size/1024.0/1024.0);
    }
}
```
![-w1117](https://raw.githubusercontent.com/jcexk/jcexk.github.io/master/images/pagefault/16188471898816.jpg)
根据打印结果可知，malloc前虚拟空间为4776MB，在创建内存100MB的字符指针时，虚拟空间增加了100MB，为4876MB，重点来了，在为前3MB个元素循环赋值时，物理地址也恰好增加了3MB，且物理空间与右侧memory工具数值一致，由此证明了前述观点。

文章来源：《程序员的自我修养》，维基百科，https://en.wikipedia.org/wiki/Virtual_address_space
